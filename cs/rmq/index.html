<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/jemdoc.css"> <link rel=icon  href="/assets/favicon.png"> <title>Rusty Solutions to the RMQ Problem</title> <main class=outside > <div class=box > <aside class=layout-menu > <div class=menu-category >Meta</div> <div class="menu-item "><a href="/">Home</a></div> <div class=menu-category >Biology</div> <div class="menu-item "><a href="/biology/cancer/">The Biology of Cancer</a></div> <div class="menu-item "><a href="/biology/dev/">Developmental Biology</a></div> <div class="menu-item "><a href="/biology/relational-biology/">Relational Biology</a></div> <div class="menu-item "><a href="/biology/readings/">Readings in Biology</a></div> <div class="menu-item "><a href="/biology/questions/">Working Questions</a></div> <div class=menu-category >Higher Maths</div> <div class="menu-item "><a href="/maths/linear-algebra/">Abstract Linear Algebra</a></div> <div class="menu-item "><a href="/maths/analysis/">Analysis</a></div> <div class="menu-item "><a href="/menu2/abstract-algebra/">Abstract Algebra</a></div> <div class="menu-item "><a href="/maths/readings/">Readings in Higher Maths</a></div> <div class=menu-category >Computational Science</div> <div class="menu-item current"><a href="/cs/dsa/">Algorithms & Data Structures</a></div> <div class="menu-item "><a href="/cs/numerical/">Numerical Algorithms</a></div> <div class="menu-item "><a href="/cs/nn-genetics/">Interpreting Neural Nets</a></div> <div class=menu-category >Misc</div> <div class="menu-item "><a href="/pol/piketty/">Capital & Ideology</a></div> <div class="menu-item "><a href="/pol/alexis/">Democracy in America</a></div> </aside> <div class=layout-content > <div class=franklin-content ><h1 id=rusty_solutions_to_the_rmq_problem ><a href="#rusty_solutions_to_the_rmq_problem" class=header-anchor >Rusty Solutions to the RMQ Problem</a></h1> <div class=franklin-toc ><ol><li><a href="#a_naïve_solution">A Naïve Solution</a><li><a href="#binary_representation_sparse_tables">Binary Representation &amp; Sparse Tables</a><ol><li><a href="#preprocessing">Preprocessing</a><li><a href="#querying_the_sparse_table">Querying the Sparse Table</a></ol><li><a href="#the_method_of_four_russians">The Method of Four Russians</a><ol><li><a href="#two-level_structures">Two-Level Structures</a><li><a href="#hybrid_structures">Hybrid Structures</a></ol><li><a href="#cartesian_trees_the_lca-rmq_equivalence">Cartesian Trees &amp; The LCA-RMQ Equivalence</a><ol><li><a href="#cartesian_trees">Cartesian Trees</a><li><a href="#cartesian_tree_isomorphisms">Cartesian Tree Isomorphisms</a><li><a href="#the_fischer-heun_rmq_structure">The Fischer-Heun RMQ Structure</a></ol><li><a href="#references">References</a></ol></div> <h2 id="a_naïve_solution"><a href="#a_naïve_solution" class=header-anchor >A Naïve Solution</a></h2> <p>The most straightforward way to solve this problem is to create a lookup table with all the RMQ answers precomputed. This will allow us to answer any RMQ in constant time by doing a table lookup. How can we build such a table? The first thing to notice is that this is a discrete optimization problem - we are interested in the minimal &#40;aka the optimal&#41; value in a given range. A quick reference to <a href="https://www.notion.so/A-note-on-algorithmic-design-patterns-20e50d39c99945e3ad8dfb804177ab3f">common algorithmic patterns</a> should tell us that we may be able to use dynamic programming to solve the problem. All we need to do is come up with an update rule. In particular, suppose our array is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> , if we know the smallest value in some range <code>&#40;i, j&#41;</code> to be <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, we can easily figure out the answer on a larger range <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(i, j+1)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >)</span></span></span></span> by comparing <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> with <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy=false >[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">A[i + 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class=mopen >[</span><span class="mord mathnormal">i</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span> . That is:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>R</mi><mi>M</mi><msub><mi>Q</mi><mi>A</mi></msub><mo stretchy=false >(</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo stretchy=false >)</mo><mo>=</mo><mrow><mo fence=true >{</mo><mtable rowspacing=0.36em  columnalign="left left" columnspacing=1em ><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mrow><mi>A</mi><mo stretchy=false >[</mo><mi>j</mi><mo stretchy=false >]</mo><mo separator=true >,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=false ><mrow><mtext>if </mtext><mi>i</mi><mo>=</mo><mi>j</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mrow><mi>min</mi><mo>⁡</mo><mrow><mo fence=true >(</mo><mi>A</mi><mo stretchy=false >[</mo><mi>j</mi><mo stretchy=false >]</mo><mo separator=true >,</mo><mi>R</mi><mi>M</mi><msub><mi>Q</mi><mi>A</mi></msub><mo stretchy=false >(</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=false >)</mo><mo fence=true >)</mo></mrow><mo separator=true >,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=false ><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex"> RMQ_A(i, j) = \begin{cases} A[j], &amp; \text{if}\ i = j \\ \min \left(A[j], RMQ_A(i, j - 1)\right), &amp; \text{otherwise} \end{cases} </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">RM</span><span class=mord ><span class="mord mathnormal">Q</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:3em;vertical-align:-1.25em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class=mord ><span class=mtable ><span class=col-align-l ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.69em;"><span style="top:-3.69em;"><span class=pstrut  style="height:3.008em;"></span><span class=mord ><span class="mord mathnormal">A</span><span class=mopen >[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mclose >]</span><span class=mpunct >,</span></span></span><span style="top:-2.25em;"><span class=pstrut  style="height:3.008em;"></span><span class=mord ><span class=mop >min</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">A</span><span class=mopen >[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mclose >]</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">RM</span><span class=mord ><span class="mord mathnormal">Q</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mord >1</span><span class=mclose >)</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mpunct >,</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.19em;"><span></span></span></span></span></span><span class=arraycolsep  style="width:1em;"></span><span class=col-align-l ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.69em;"><span style="top:-3.69em;"><span class=pstrut  style="height:3.008em;"></span><span class=mord ><span class="mord text"><span class=mord >if</span></span><span class=mspace > </span><span class="mord mathnormal">i</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span><span style="top:-2.25em;"><span class=pstrut  style="height:3.008em;"></span><span class=mord ><span class="mord text"><span class=mord >otherwise</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> <p>We can do this for all possible values of <code>i</code> and <code>j</code> to fill up our lookup table. This takes quadratic time. Thus, with this approach, we cam solve the RMQ problem in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=false >)</mo><mo separator=true >,</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle\Theta(n^2), \Theta(1)\rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class=mord >Θ</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >Θ</span><span class=mopen >(</span><span class=mord >1</span><span class=mclose >)⟩</span></span></span></span>.</p> <p>The code below implements this approach. The only modification we make is that instead or calculating the actual minimal value, we calculate the index of the smallest value. That is <code>argmin</code> instead of <code>min</code></p> <pre><code class="rs hljs"><span class=hljs-comment >/// An inclusive ([i, j]), 0 indexed range for specifying a range</span>
<span class=hljs-comment >/// query.</span>
<span class=hljs-meta >#[derive(Eq, PartialEq, Hash)]</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">RMQRange</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-comment >/// The starting index, i</span>
    start_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The last index, j</span>
    end_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The array to which the indexes above refer. Keeping</span>
    <span class=hljs-comment >/// a reference here ensures that some key invariants are</span>
    <span class=hljs-comment >/// not violated. Since it is expected that the underlying</span>
    <span class=hljs-comment >/// array will be static, we&#x27;ll never make a mutable reference</span>
    <span class=hljs-comment >/// to it. As such, storing shared references in many</span>
    <span class=hljs-comment >/// different RMQRange objects should be fine</span>
    underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T]
}</code></pre> <p>To make it easy to construct new range objects, we implement the <code>From</code> trait. This implementation will allow us to construct an <code>RMQRange</code> object from a <code>3-Tuple</code> by simply invoking <code>&#40;a, b, c&#41;.into</code>. We also do error checking here to make sure that we can only ever create valid ranges.</p> <pre><code class="rs hljs"><span class=hljs-keyword >impl</span> &lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; <span class=hljs-built_in >From</span>&lt;(<span class=hljs-type >usize</span>, <span class=hljs-type >usize</span>, &amp;<span class=hljs-symbol >&#x27;a</span> [T])&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">RMQRange</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">from</span>(block: (<span class=hljs-type >usize</span>, <span class=hljs-type >usize</span>, &amp;<span class=hljs-symbol >&#x27;a</span> [T])) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >start_idx</span> = block.<span class=hljs-number >0</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-variable >end_idx</span> = block.<span class=hljs-number >1</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-variable >len</span> = block.<span class=hljs-number >2</span>.<span class="hljs-title function_ invoke__">len</span>();
        <span class=hljs-keyword >if</span> start_idx &gt; end_idx {
            <span class=hljs-built_in >panic!</span>(<span class=hljs-string >&quot;Range start cannot be larger than the range&#x27;s end&quot;</span>)
        }
        <span class=hljs-keyword >if</span> end_idx &gt;= len {
            <span class=hljs-built_in >panic!</span>(<span class=hljs-string >&quot;Range end cannot be &gt;= the len of underlying array&quot;</span>)
        }
        RMQRange {
            start_idx,
            end_idx,
            underlying: block.<span class=hljs-number >2</span>
        }
    }
}</code></pre> <p>With the abstractions above, we can go ahead and implement our procedure.</p> <pre><code class="rs hljs"><span class=hljs-keyword >type</span> <span class="hljs-title class_">LookupTable</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; = HashMap&lt;RMQRange&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;, <span class=hljs-type >usize</span>&gt;;

<span class=hljs-comment >/// Computes the answers to all possible queries.</span>
<span class=hljs-comment >/// Since the ending index of a query</span>
<span class=hljs-comment >/// is lower bounded by the starting index, </span>
<span class=hljs-comment >/// the resulting lookup table is an</span>
<span class=hljs-comment >/// upper triangular matrix. Therefore, instead of</span>
<span class=hljs-comment >/// representing it as a matrix,</span>
<span class=hljs-comment >/// we use a hashmap instead (to save space)</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">compute_rmq_all_ranges</span>&lt;T&gt;(array: &amp;[T]) <span class=hljs-punctuation >-&gt;</span> LookupTable&lt;<span class=hljs-symbol >&#x27;_</span>, T&gt; 
<span class=hljs-keyword >where</span>
    T: Hash + <span class=hljs-built_in >Eq</span> + <span class=hljs-built_in >Ord</span>
{
    <span class=hljs-keyword >let</span> <span class=hljs-variable >len</span> = array.<span class="hljs-title function_ invoke__">len</span>();
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >lookup_table</span> = HashMap::<span class="hljs-title function_ invoke__">with_capacity</span>((len * len) / <span class=hljs-number >2</span>);
    <span class=hljs-keyword >for</span> <span class=hljs-variable >start</span> <span class=hljs-keyword >in</span> <span class=hljs-number >0</span>..len {
        <span class=hljs-keyword >for</span> <span class=hljs-variable >end</span> <span class=hljs-keyword >in</span> start..len {
            <span class=hljs-keyword >if</span> start == end {
                lookup_table.<span class="hljs-title function_ invoke__">insert</span>((start, end, array).<span class="hljs-title function_ invoke__">into</span>(), start);
            } <span class=hljs-keyword >else</span> {
                <span class=hljs-keyword >let</span> <span class=hljs-variable >prev_range</span> = (start, end - <span class=hljs-number >1</span>, array).<span class="hljs-title function_ invoke__">into</span>();
                <span class=hljs-keyword >let</span> <span class=hljs-variable >new_range</span> = (start, end, array).<span class="hljs-title function_ invoke__">into</span>();
                <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >min_idx</span> = *lookup_table.<span class="hljs-title function_ invoke__">get</span>(&amp;prev_range).<span class="hljs-title function_ invoke__">unwrap</span>();
                <span class=hljs-keyword >if</span> array[min_idx] &gt; array[end] {
                    min_idx = end;
                }
                lookup_table.<span class="hljs-title function_ invoke__">insert</span>(new_range, min_idx);
            }
        }
    }
    lookup_table
}</code></pre> <p>You can play around with the code so far <a href="https://play.rust-lang.org/?version&#61;stable&amp;mode&#61;debug&amp;edition&#61;2018&amp;gist&#61;ccb49819827b6e1834765389f7ecf12b">in the playground</a></p> <p>Can we do better than <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=false >)</mo><mo separator=true >,</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle\Theta(n^2), \Theta(1)\rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class=mord >Θ</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >Θ</span><span class=mopen >(</span><span class=mord >1</span><span class=mclose >)⟩</span></span></span></span> ? The query time is the best we can ever hope for. However, we can reduce the processing time. Let&#39;s see how we can do that in the next section.</p> <h2 id=binary_representation_sparse_tables ><a href="#binary_representation_sparse_tables" class=header-anchor >Binary Representation &amp; Sparse Tables</a></h2> <p>Any positive integer can be factored into a sum of powers of two. This binary factorization is the basis of binary representation. For instance, the decimal number 19 can be represented as:</p> <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>19</mn><mo>=</mo><mn>16</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn><mn>4</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo><mn>0</mn><mo>∗</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mo stretchy=false >(</mo><mn>10011</mn><msub><mo stretchy=false >)</mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">19 = 16 + 2 + 1 = 2^4 + 0*2^3 + 0*2^2 + 2^1 + 2^0 = (10011)_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >19</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >16</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.7278em;vertical-align:-0.0833em;"></span><span class=mord >2</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8974em;vertical-align:-0.0833em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >0</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∗</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.8974em;vertical-align:-0.0833em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >0</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∗</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.8974em;vertical-align:-0.0833em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.8974em;vertical-align:-0.0833em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.8141em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >10011</span><span class=mclose ><span class=mclose >)</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <p>Given some range <code>&#91;i, j&#93;</code> we know that its length, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy=false >)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(j - i) + 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span></span></span></span> is positive. We can therefore factor it using binary factorization to get shorter ranges. For instance, if our range is <code>&#40;0, 18&#41;</code> we see that it has a length of <code>19</code> which, as we saw above, can be be factored into <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mn>0</mn><mo separator=true >,</mo><mn>15</mn><mo stretchy=false >)</mo><mo>+</mo><mo stretchy=false >(</mo><mn>16</mn><mo separator=true >,</mo><mn>17</mn><mo stretchy=false >)</mo><mo>+</mo><mo stretchy=false >(</mo><mn>18</mn><mo separator=true >,</mo><mn>18</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(0, 15) + (16, 17) + (18, 18)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >15</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >16</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >17</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >18</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >18</span><span class=mclose >)</span></span></span></span>.</p> <h3 id=preprocessing ><a href="#preprocessing" class=header-anchor >Preprocessing</a></h3> <p>How can we use these observations to construct a solution to our problem? First, note that powers of two are sparsely distributed among positive integers. Also, because they can be combined to form any other number, if we had a table with answers to all possible ranges whose size is a power of two, we would be able to get answers for any range. How can we construct such sparse table?</p> <p>For an array of length <code>k</code>, there are <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\log k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ranges whose size is a power of two &#40;just as there are <code>lg x</code> bits in the binary representation of <code>x</code>&#41;. We shall thus construct the sparse table by computing answers to all <code>lg n</code> ranges for all <code>n</code> possible values of <code>n</code>. Therefore, the time needed to create the sparse table is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \log n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)</span></span></span></span>. We implement this scheme below.</p> <pre><code class="rs hljs"><span class=hljs-comment >/// An index into our sparse table</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">SparseTableIdx</span> {
    <span class=hljs-comment >/// The index where the range in question begins</span>
    start_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The length of the range. This has to always be a power of</span>
    <span class=hljs-comment >/// two</span>
    len: <span class=hljs-type >usize</span>
}

<span class=hljs-keyword >impl</span> <span class="hljs-title class_">From</span>&lt;(<span class=hljs-type >usize</span>, <span class=hljs-type >usize</span>)&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">SparseTableIdx</span> {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">from</span>(idx_tuple: (<span class=hljs-type >usize</span>, <span class=hljs-type >usize</span>)) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >start_idx</span> = idx_tuple.<span class=hljs-number >0</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-variable >len</span> = idx_tuple.<span class=hljs-number >1</span>;
        <span class=hljs-keyword >if</span> !len.<span class="hljs-title function_ invoke__">is_power_of_two</span>() {
            <span class=hljs-built_in >panic!</span>(<span class=hljs-string >&quot;Expected the length to be a power or 2&quot;</span>)
        }
        SparseTableIdx { start_idx, len }
    }
}</code></pre> <pre><code class="rs hljs"><span class=hljs-comment >/// A sparse table is simply a collection</span>
<span class=hljs-comment >/// of rmq answers for ranges whose</span>
<span class=hljs-comment >/// length is a power of two. We pre-compute </span>
<span class=hljs-comment >/// such ranges for all possible starting</span>
<span class=hljs-comment >/// positions</span>
<span class=hljs-keyword >type</span> <span class="hljs-title class_">SparseTable</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; = HashMap&lt;SparseTableIdx, RMQResult&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt;;

<span class=hljs-comment >/// The DP update rule for populating the sparse table. The</span>
<span class=hljs-comment >/// smallest value in a range whose length is 1 &lt;&lt; k is</span>
<span class=hljs-comment >/// the min of the two ranges that form that range</span>
<span class=hljs-comment >/// each of length 1 &lt;&lt; (k - 1)</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">get_prev_min</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: Hash + <span class=hljs-built_in >Eq</span> + <span class=hljs-built_in >Ord</span>&gt;(
    array: &amp;<span class=hljs-symbol >&#x27;a</span> [T],
    left_res: &amp;RMQResult&lt;T&gt;,
    right_res: &amp;RMQResult&lt;T&gt;,
) <span class=hljs-punctuation >-&gt;</span> RMQResult&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >if</span> left_res.min_value &lt; right_res.min_value {
        (left_res.min_idx, &amp;array[left_res.min_idx]).<span class="hljs-title function_ invoke__">into</span>()
    } <span class=hljs-keyword >else</span> {
        (right_res.min_idx, &amp;array[right_res.min_idx]).<span class="hljs-title function_ invoke__">into</span>()
    }
}</code></pre> <pre><code class="rs hljs"><span class=hljs-comment >/// For each index `i`, compute RMQ answers for ranges starting at `i` of</span>
<span class=hljs-comment >/// size `1, 2, 4, 8, 16, …, 2^k` as long as the resultant ending index</span>
<span class=hljs-comment >/// fits in the underlying array in the array.</span>
<span class=hljs-comment >/// For each array index, we compute lg n ranges. Therefore,</span>
<span class=hljs-comment >/// the total cost of the procedure is O(n lg n)</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">compute_rmq_sparse</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;(array: &amp;<span class=hljs-symbol >&#x27;a</span> [T]) <span class=hljs-punctuation >-&gt;</span> SparseTable&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; 
<span class=hljs-keyword >where</span>
    T:  Hash + <span class=hljs-built_in >Eq</span> + <span class=hljs-built_in >Ord</span>
{
    <span class=hljs-keyword >let</span> <span class=hljs-variable >len</span> = array.<span class="hljs-title function_ invoke__">len</span>();
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >sparse_table</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >power</span> = <span class=hljs-number >0</span>;
    <span class=hljs-keyword >while</span> <span class=hljs-number >1</span> &lt;&lt; power &lt;= len {
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >start_idx</span> = <span class=hljs-number >0</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >end_idx</span> = start_idx + (<span class=hljs-number >1</span> &lt;&lt; power) - <span class=hljs-number >1</span>;
        <span class=hljs-keyword >while</span> end_idx &lt; len {
            <span class=hljs-keyword >if</span> start_idx == end_idx {
                <span class=hljs-keyword >let</span> <span class=hljs-variable >idx</span> = (start_idx, <span class=hljs-number >1</span> &lt;&lt; power).<span class="hljs-title function_ invoke__">into</span>();
                <span class=hljs-keyword >let</span> <span class=hljs-variable >rmq_res</span> = (start_idx, &amp;array[start_idx]).<span class="hljs-title function_ invoke__">into</span>();
                sparse_table.<span class="hljs-title function_ invoke__">insert</span>(idx, rmq_res);
            } <span class=hljs-keyword >else</span> {
                <span class=hljs-keyword >let</span> <span class=hljs-variable >idx</span> = (start_idx, <span class=hljs-number >1</span> &lt;&lt; power).<span class="hljs-title function_ invoke__">into</span>();
                <span class=hljs-keyword >let</span> <span class=hljs-variable >prev_len</span> = <span class=hljs-number >1</span> &lt;&lt; (power - <span class=hljs-number >1</span>);
                <span class=hljs-keyword >let</span> <span class=hljs-variable >left</span>: SparseTableIdx = (start_idx, prev_len).<span class="hljs-title function_ invoke__">into</span>();
                <span class=hljs-keyword >let</span> <span class=hljs-variable >right</span>: SparseTableIdx = (start_idx + prev_len, prev_len);
                <span class=hljs-keyword >let</span> <span class=hljs-variable >left_res</span> = sparse_table.<span class="hljs-title function_ invoke__">get</span>(&amp;left).<span class="hljs-title function_ invoke__">unwrap</span>();
                <span class=hljs-keyword >let</span> <span class=hljs-variable >right_res</span> = sparse_table.<span class="hljs-title function_ invoke__">get</span>(&amp;right).<span class="hljs-title function_ invoke__">unwrap</span>();
                <span class=hljs-keyword >let</span> <span class=hljs-variable >rmq_res</span> = <span class="hljs-title function_ invoke__">get_prev_min</span>(array, left_res, right_res);
                sparse_table.<span class="hljs-title function_ invoke__">insert</span>(idx, rmq_res);
            }
            start_idx += <span class=hljs-number >1</span>;
            end_idx += <span class=hljs-number >1</span>;
        }
        power += <span class=hljs-number >1</span>;
    }
    sparse_table
}</code></pre> <h3 id=querying_the_sparse_table ><a href="#querying_the_sparse_table" class=header-anchor >Querying the Sparse Table</a></h3> <p>Now that we have our sparse table, how can we query from it given an arbitrary range <code>R &#61; &#91;i, j&#93;</code>? From our initial discussion of binary factorization, you can imagine computing all sub-ranges of <code>R</code> whose length is a power of 2 and then taking the min over these values. For an arbitrary length <code>n</code>, there are <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy=false >(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">O(\lg n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)</span></span></span></span> such sub-ranges. Thus, this scheme would give us a <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle\Theta(n\lg n), \Theta(\lg n)\rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class=mord >Θ</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >Θ</span><span class=mopen >(</span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)⟩</span></span></span></span> solution to the <code>RMQ</code>problem. </p> <p>Computing all sub-ranges, however, is overkill. All we need are two sub-ranges that fully cover the underlying segment. How do we find the two covering segments? First, observe that if the length of the range is an exact power of two, then we do not need to do any further computation since we already precomputed answers for all such ranges. If its not, we start by finding the largest sub-range that is an exact power of two. Specifically, we find the value <code>k</code> such that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>≤</mo><mo stretchy=false >(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy=false >)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k \leq (j - i) + 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.9851em;vertical-align:-0.136em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >≤</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >1</span></span></span></span>. Note that this value <code>k</code> is the index of the most significant bit of the range&#39;s length. The first range is thus <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mi>i</mi><mo separator=true >,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[i, i + 2^k - 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.9324em;vertical-align:-0.0833em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>. That is, a range whose length is <code>2^&#40;k&#41; - 1</code>. After finding the largest sub-range, the remaining portion&#39;s length certainly be not be a power of two. To proceed, we use a neat trick: we construct a range whose length is the smallest power of two larger than the remaining portion length. To prevent this sub-range from overflowing the underlying range, we shift it over to the left, overlapping the first subr-ange, until it is full contained in the original range. The second range is thus <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mi>j</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn><mo separator=true >,</mo><mi>j</mi><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[j - 2^k + 1, j]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:0.9324em;vertical-align:-0.0833em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mclose >]</span></span></span></span>, with a length of <code>2^&#40;k&#41; - 1</code> as well.</p> <p>To recapitulate, we query from the sparse table by finding the <code>argmin</code> of two overlapping ranges whose answers have already been computed. Figuring out which ranges to use involves finding the <code>MSB&#40;n&#41;</code> where <code>n</code> is the length of the range in the query. How so we calculate <code>MSB&#40;n&#41;</code>? To compute <code>MSB&#40;n&#41;</code> in constant time, we can use a lookup table. Later on, when discussing specialized integer containers, we&#39;ll implement a complex but straightforward method for finding <code>k</code> in constant time. For now, a lookup table suffices. Thus, with this scheme, we have a <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi mathvariant=normal >Θ</mi><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle\Theta(n\lg n), \Theta(1)\rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class=mord >Θ</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mord >Θ</span><span class=mopen >(</span><span class=mord >1</span><span class=mclose >)⟩</span></span></span></span> solution to the <code>RMQ</code> problem. Below, we implement a procedure to compute the lookup table.</p> <pre><code class="rust hljs"><span class=hljs-comment >/// Here&#x27;s the scheme we shall use to implement the lookup table:</span>
<span class=hljs-comment >///    - First, we shall assume that the values we get are 8 bytes (64bits) wide</span>
<span class=hljs-comment >///    - We shall pre-compute all MSB(n) values for all n &lt;= 2^16. This will use</span>
<span class=hljs-comment >///       65536 bytes which is approximately 66Kb.</span>
<span class=hljs-comment >///    - To find the MSB of any value, we combine answers from the 4 16 bit</span>
<span class=hljs-comment >///       portions using logical shifts and masks</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">MSBLookupTable</span>([<span class=hljs-type >u8</span>; <span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >16</span>]);

<span class=hljs-keyword >impl</span> <span class="hljs-title class_">MSBLookupTable</span> {
    <span class=hljs-comment >/// Build the lookup table. To fill up the table, we simply subdivide</span>
    <span class=hljs-comment >/// it into segments whose sizes are powers of two. The MSBa in a segment</span>
    <span class=hljs-comment >/// are the same. For instance:</span>
    <span class=hljs-comment >///   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
    <span class=hljs-comment >/// n       |1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|...</span>
    <span class=hljs-comment >/// msb(n)  |0|1|1|2|2|2|2|3|3|3 |3 |3 |3 |3 |3 |4 |4 |4 |4 |...</span>
    <span class=hljs-comment >///   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
    <span class=hljs-keyword >pub</span> <span class=hljs-keyword >fn</span> <span class="hljs-title function_">build</span>() <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >lookup_table</span> = [<span class=hljs-number >0</span>; <span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >16</span>];
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >msb_idx</span> = <span class=hljs-number >0</span>;
        <span class=hljs-keyword >for</span> <span class=hljs-variable >i</span> <span class=hljs-keyword >in</span> <span class=hljs-number >0</span>..lookup_table.<span class="hljs-title function_ invoke__">len</span>() {
            <span class=hljs-keyword >let</span> <span class=hljs-variable >n</span> = i + <span class=hljs-number >1</span>;
            <span class=hljs-keyword >if</span> n &gt; <span class=hljs-number >1</span> &amp;&amp; n.<span class="hljs-title function_ invoke__">is_power_of_two</span>() {
                msb_idx += <span class=hljs-number >1</span>;
            }
            lookup_table[i] = msb_idx;
        }
        <span class="hljs-title function_ invoke__">MSBLookupTable</span>(lookup_table)
    }

    <span class=hljs-comment >/// Get the most significant bit of the given 64 bit value. A 64 bit</span>
    <span class=hljs-comment >/// bit number can be subdivided into 4 16 bit portions. Since we have</span>
    <span class=hljs-comment >/// pre-calculated the msb values for all possible 16 bit integers,</span>
    <span class=hljs-comment >/// we can find the msb of the number by combining answers to each segment</span>
    <span class=hljs-keyword >pub</span> <span class=hljs-keyword >fn</span> <span class="hljs-title function_">get_msb_idx_of</span>(&amp;<span class=hljs-keyword >self</span>, n: <span class=hljs-type >usize</span>) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >u8</span> {
        <span class=hljs-built_in >debug_assert!</span>(n != <span class=hljs-number >0</span>);
        <span class=hljs-keyword >let</span> <span class=hljs-variable >bit_mask</span> = <span class=hljs-number >0xFFFF</span>;
        <span class=hljs-keyword >if</span> n &gt;&gt; <span class=hljs-number >48</span> &gt; <span class=hljs-number >0</span> {
            <span class=hljs-keyword >let</span> <span class=hljs-variable >d_idx</span> = (n &gt;&gt; <span class=hljs-number >48</span>) - <span class=hljs-number >1</span>;
            <span class=hljs-keyword >self</span>.<span class=hljs-number >0</span>[d_idx] + <span class=hljs-number >48</span>
        } <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> n &gt;&gt; <span class=hljs-number >32</span> &gt; <span class=hljs-number >0</span> {
            <span class=hljs-keyword >let</span> <span class=hljs-variable >c_idx</span> = ((n &gt;&gt; <span class=hljs-number >32</span>) &amp; bit_mask) - <span class=hljs-number >1</span>;
            <span class=hljs-keyword >self</span>.<span class=hljs-number >0</span>[c_idx] + <span class=hljs-number >32</span>
        } <span class=hljs-keyword >else</span> <span class=hljs-keyword >if</span> n &gt;&gt; <span class=hljs-number >16</span> &gt; <span class=hljs-number >0</span> {
            <span class=hljs-keyword >let</span> <span class=hljs-variable >b_idx</span> = ((n &gt;&gt; <span class=hljs-number >16</span>) &amp; bit_mask) - <span class=hljs-number >1</span>;
            <span class=hljs-keyword >self</span>.<span class=hljs-number >0</span>[b_idx] + <span class=hljs-number >16</span>
        } <span class=hljs-keyword >else</span> {
            <span class=hljs-keyword >let</span> <span class=hljs-variable >a_idx</span> = (n &amp; bit_mask) - <span class=hljs-number >1</span>;
            <span class=hljs-keyword >self</span>.<span class=hljs-number >0</span>[a_idx]
        }
    }
}</code></pre> <p>Once again, the query time is the best possible. However, even though the pre-processing time reduced from quadratic to <code>O&#40;n lg n&#41;</code>, we can still do better. In particular, we can shave off a log factor and arrive at a linear time pre-processing algorithm. To figure out how to do that, we shall take a detour to discuss the method of four russians.</p> <p>If you&#39;d like to take a breather, feel free to play around with the sparse table code in <a href="https://play.rust-lang.org/?version&#61;stable&amp;mode&#61;debug&amp;edition&#61;2018&amp;gist&#61;7f9c152dee95816d7ef8ef9d14bc1f72">the rust playground</a>.</p> <hr /> <h2 id=the_method_of_four_russians ><a href="#the_method_of_four_russians" class=header-anchor >The Method of Four Russians</a></h2> <p>We begin this detour by taking another detour. Let us discuss the algorithms used to find the median &#40;or more generally, the <code>i_th</code> order statistic&#41; of a collection of pairwise comparable items. <code>Quickselect</code> can solve this problem in expected linear time. However, if we want a worst case linear time solution, we need to use the <code>Median of Medians</code> procedure.</p> <p><code>MoM</code> is exactly similar <code>Quickselelect</code> except, instead of randomly picking the index to partition around, we compute an approximate median value. We begin by dividing the input collection into blocks of <code>length&#61;5</code>. This gives us <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⌈</mo><mfrac><mi>n</mi><mn>5</mn></mfrac><mo stretchy=false >⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{n}{5}\rceil</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.095em;vertical-align:-0.345em;"></span><span class=mopen >⌈</span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.6954em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mclose >⌉</span></span></span></span> blocks, with the final block possibly having <code>&lt; 5</code> items. For each block, we calculate the median by first sorting and selection the lower median. For a single block, this always takes constant time, meaning that finding the median for all blocks takes linear time. We aggregate all the block-level medians into a single array. This array is of length <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⌈</mo><mfrac><mi>n</mi><mn>5</mn></mfrac><mo stretchy=false >⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{n}{5}\rceil</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.095em;vertical-align:-0.345em;"></span><span class=mopen >⌈</span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.6954em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mclose >⌉</span></span></span></span>. Once we have aggregated the lock level medians, we are faced with the xeact same problem we started with – just on a much smaller array. Therefore, we can recursively find the median of this new array. Once we have this value, we can proceed as usual, using the <a href="https://www.notion.so/A-note-on-algorithmic-design-patterns-20e50d39c99945e3ad8dfb804177ab3f">prune and conquer</a> strategy. Below, we implement this scheme</p> <pre><code class="rs hljs"><span class=hljs-comment >/// The abstraction for a single block.</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">MedianBlock</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-comment >/// The starting index. This is 0-indexed and should be</span>
    <span class=hljs-comment >/// less than or equal to the end_idx</span>
    start_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The ending index. This should be strictly less than the</span>
    <span class=hljs-comment >/// length of the underlying array. Further, end_idx - start_idx should</span>
    <span class=hljs-comment >/// be 5 for all except possibly the last block</span>
    end_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The index of the median value in the given range. To move from this</span>
    <span class=hljs-comment >/// index to an indx in the underlying, we simply calculate</span>
    <span class=hljs-comment >/// `start_idx + median_idx`</span>
    median_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The median of this block</span>
    median: &amp;<span class=hljs-symbol >&#x27;a</span> T,
}

<span class=hljs-comment >/// For quick construction and error checking.</span>
<span class=hljs-comment >// (start_idx, end_idx, underlying, median_idx)</span>
<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; <span class=hljs-built_in >From</span>&lt;(<span class=hljs-type >usize</span>, <span class=hljs-type >usize</span>, &amp;<span class=hljs-symbol >&#x27;a</span> [T], <span class=hljs-type >usize</span>)&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">MedianBlock</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">from</span>(block: (<span class=hljs-type >usize</span>, <span class=hljs-type >usize</span>, &amp;<span class=hljs-symbol >&#x27;a</span> [T], <span class=hljs-type >usize</span>)) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >start_idx</span> = block.<span class=hljs-number >0</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >end_idx</span> = block.<span class=hljs-number >1</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-variable >len</span> = block.<span class=hljs-number >2</span>.<span class="hljs-title function_ invoke__">len</span>();
        <span class=hljs-keyword >let</span> <span class=hljs-variable >median_idx</span> = block.<span class=hljs-number >3</span>;
        <span class=hljs-keyword >if</span> end_idx &gt;= len {
            end_idx = len - <span class=hljs-number >1</span>;
        }
        <span class=hljs-built_in >debug_assert!</span>(start_idx &lt; end_idx);
        <span class=hljs-built_in >debug_assert!</span>(median_idx &gt;= start_idx &amp;&amp; median_idx &lt;= end_idx);
        <span class=hljs-keyword >if</span> end_idx &lt; len {
            <span class=hljs-built_in >debug_assert!</span>(end_idx - start_idx == <span class=hljs-number >5</span>);
        }
        MedianBlock {
            start_idx,
            end_idx,
            median_idx,
            median: &amp;block.<span class=hljs-number >2</span>[median_idx]
        }
    }
}</code></pre> <p>With the above abstractions in place, we can go ahead and implement the main procedure</p> <pre><code class="rs hljs"><span class=hljs-comment >//! Median of Medians Helper Functions. </span>
<span class=hljs-comment >//! These will come in handy when implementing</span>
<span class=hljs-comment >//! multi-level data structures that use the method of four russians</span>

<span class=hljs-comment >/// Block partitioning and aggregation. This is the same for all</span>
<span class=hljs-comment >/// Method of Four Russians Algorithms</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">generate_macro_array</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt;(array: &amp;<span class=hljs-symbol >&#x27;a</span> [T]) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >Vec</span>&lt;MedianBlock&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt; {
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >blocks</span> = <span class=hljs-type >Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(array.<span class="hljs-title function_ invoke__">len</span>()/<span class=hljs-number >5</span>);
    <span class=hljs-keyword >for</span> <span class=hljs-variable >start_idx</span> <span class=hljs-keyword >in</span> (<span class=hljs-number >0</span>..array.<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">step_by</span>(<span class=hljs-number >5</span>) {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >end_idx</span> = (start_idx + <span class=hljs-number >5</span>) - <span class=hljs-number >1</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-variable >block</span> = &amp;array[start_idx..=end_idx];
        <span class=hljs-keyword >let</span> <span class=hljs-variable >median_idx</span> = <span class="hljs-title function_ invoke__">get_kth_by_sorting</span>(block, block.<span class="hljs-title function_ invoke__">len</span>() / <span class=hljs-number >2</span>);
        blocks.<span class="hljs-title function_ invoke__">push</span>((start_idx, end_idx, array, median_idx).<span class="hljs-title function_ invoke__">into</span>())
    }
    blocks
}

<span class=hljs-comment >/// This solves the problem for a single block.</span>
<span class=hljs-comment >/// This changes from problem to problem.</span>
<span class=hljs-comment >/// For instance, when we solving RMQ, </span>
<span class=hljs-comment >/// this will be get_min_idx_by_scanning. You can</span>
<span class=hljs-comment >/// definitely think of a way of creating</span>
<span class=hljs-comment >/// an abstraction that can solve any</span>
<span class=hljs-comment >/// method of four russians problem by having</span>
<span class=hljs-comment >/// the client provide a function for</span>
<span class=hljs-comment >/// block partitioning and solving the block level problem. </span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">get_kth_by_sorting</span>&lt;T: <span class=hljs-built_in >Ord</span>&gt;(block: &amp;[T], k: <span class=hljs-type >usize</span>) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >usize</span> {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >kth</span> = block
        .<span class="hljs-title function_ invoke__">iter</span>()
        .<span class="hljs-title function_ invoke__">enumerate</span>()
        .<span class="hljs-title function_ invoke__">sorted_by_key</span>(|x| x.<span class=hljs-number >1</span>)
        .<span class="hljs-title function_ invoke__">map</span>(|x| x.<span class=hljs-number >0</span>)
        .<span class="hljs-title function_ invoke__">nth</span>(k);
    kth.<span class="hljs-title function_ invoke__">unwrap</span>()
}

<span class=hljs-comment >/// Reorient the elements of the array around the element at `pivot_idx` and</span>
<span class=hljs-comment >/// return the length of the left partition</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">partition_at_pivot</span>&lt;T: <span class=hljs-built_in >Ord</span>&gt;(array: &amp;<span class=hljs-keyword >mut</span> [T], pivot_idx: <span class=hljs-type >usize</span>) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >usize</span> {
    <span class=hljs-keyword >let</span> <span class=hljs-variable >last_idx</span> = array.<span class="hljs-title function_ invoke__">len</span>() - <span class=hljs-number >1</span>;
    array.<span class="hljs-title function_ invoke__">swap</span>(pivot_idx, last_idx);
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >less_than_tail</span> = <span class=hljs-number >0</span>;
    <span class=hljs-keyword >for</span> <span class=hljs-variable >cur_idx</span> <span class=hljs-keyword >in</span> <span class=hljs-number >0</span>..last_idx {
        <span class=hljs-keyword >if</span> array[cur_idx] &lt;= array[last_idx] {
            array.<span class="hljs-title function_ invoke__">swap</span>(less_than_tail, cur_idx);
            less_than_tail += <span class=hljs-number >1</span>;
        }
    }
    array.<span class="hljs-title function_ invoke__">swap</span>(less_than_tail, last_idx);
    less_than_tail + <span class=hljs-number >1</span>
}

<span class=hljs-comment >/// recursively calculate the median of the median blocks. This will give us an</span>
<span class=hljs-comment >/// approximate median that guarantees us a roughly even split</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">get_approx_median_idx</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span> + <span class=hljs-built_in >Clone</span>&gt;(
    macro_array: &amp;<span class=hljs-keyword >mut</span> [MedianBlock&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;]
) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >usize</span>
{
    <span class=hljs-keyword >let</span> <span class=hljs-variable >median_pos</span> = macro_array.<span class="hljs-title function_ invoke__">len</span>() / <span class=hljs-number >2</span>;
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >medians</span>: <span class=hljs-type >Vec</span>&lt;_&gt; = macro_array.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x.median).<span class="hljs-title function_ invoke__">collect</span>();
    <span class=hljs-keyword >let</span> <span class=hljs-variable >approx_median</span> = <span class="hljs-title function_ invoke__">kth_order_statistic</span>(&amp;<span class=hljs-keyword >mut</span> medians, median_pos);
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >median_idx</span> = <span class=hljs-number >0</span>;
    <span class=hljs-keyword >for</span> <span class=hljs-variable >block</span> <span class=hljs-keyword >in</span> macro_array {
        <span class=hljs-keyword >if</span> block.median == approx_median {
            median_idx = block.start_idx + block.median_idx;
        }
    }
    median_idx
}</code></pre> <pre><code class="rs hljs"><span class=hljs-comment >/// Computes the index of the k-th smallest element</span>
<span class=hljs-comment >/// in the `array`. This is sometimes</span>
<span class=hljs-comment >/// referred to as the k-th order statistic. </span>
<span class=hljs-comment >/// This procedure computes this value in</span>
<span class=hljs-comment >/// O(n). Note that this is a more general method</span>
<span class=hljs-comment >/// for finding the median i.e the (n/2)-th order statistic</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">kth_order_statistic</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;(array: &amp;<span class=hljs-symbol >&#x27;a</span> <span class=hljs-keyword >mut</span> [T], k: <span class=hljs-type >usize</span>) <span class=hljs-punctuation >-&gt;</span> &amp;T 
<span class=hljs-keyword >where</span>
    T:  <span class=hljs-built_in >Ord</span> + <span class=hljs-built_in >Clone</span>
{
    <span class=hljs-keyword >match</span> <span class=hljs-number >5</span>.<span class="hljs-title function_ invoke__">cmp</span>(&amp;array.<span class="hljs-title function_ invoke__">len</span>()) {
        Ordering::Less | Ordering::Equal =&gt; {
            &amp;array[<span class="hljs-title function_ invoke__">get_kth_by_sorting</span>(array, k)]
        },
        Ordering::Greater =&gt; {
            <span class=hljs-keyword >let</span> <span class=hljs-variable >macro_array</span> = <span class="hljs-title function_ invoke__">generate_macro_array</span>(array);
            <span class=hljs-keyword >let</span> <span class=hljs-variable >approx_median_idx</span> = <span class="hljs-title function_ invoke__">get_approx_median_idx</span>(&amp;macro_array);
            <span class=hljs-keyword >let</span> <span class=hljs-variable >left_range_size</span> = <span class="hljs-title function_ invoke__">partition_at_pivot</span>(array, approx_median_idx);
            <span class=hljs-keyword >match</span> k.<span class="hljs-title function_ invoke__">cmp</span>(&amp;left_range_size) {
                Ordering::Equal =&gt; &amp;array[k - <span class=hljs-number >1</span>],
                Ordering::Less =&gt; {
                    <span class="hljs-title function_ invoke__">kth_order_statistic</span>(&amp;<span class=hljs-keyword >mut</span> array[..left_range_size], k)
                },
                Ordering::Greater =&gt; {
                    <span class="hljs-title function_ invoke__">kth_order_statistic</span>(
                        &amp;<span class=hljs-keyword >mut</span> array[left_range_size..],
                        k - left_range_size
                    )
                }
            }
        }
    }
}</code></pre> <p>You can play around with the code for computing the <code>kth_order_statistic</code> <a href="https://play.rust-lang.org/?version&#61;stable&amp;mode&#61;debug&amp;edition&#61;2018&amp;gist&#61;02f915a79be3e7b6aadf53cfc1f29156">in the playground</a>.</p> <p><hr /> The median of medians procedure has a few key structures:</p> <ul> <li><p>The input is divided into blocks or equal size. This is called block partitioning and each block is called the micro array.</p> <li><p>The original problem &#40;median in this case&#41; is solved for each block using a naive method that works well for small input sizes. With this scheme, we are able to solve the problem for each block in constant time and for all blocks in linear time.</p> <li><p>The solutions to all blocks are aggregated into a single array. We call this the macro array. The macro array, just like the micro arrays, are smaller instances of the original problem.</p> <li><p>By combining, in some bespoke fashion, the macro and micro array solutions, we are able to solve the original problem with a log factor shaved off. In <code>MoM</code> we went from <code>Quickselect&#39;s</code> <code>O&#40;n lg n&#41;</code> to <code>O&#40;n&#41;</code> &#40;For a rigorous runtime analysis of the median of medians method, please refer to CLRS chapter 9&#41;. </p> </ul> <p>The structures above are the four major motifs in the method of four russians. How can we use this method to reduce the pre-processing time of our RMQ algorithm? We discuss that after the following interlude.</p> <p><hr /> Thus far, we&#39;ve implemented procedures to solve the <code>rmq</code> problem as free standing functions. Before we move forward, lets take a step back and see if we can come up with a much more elegant abstraction that unifies all the different solution methods. This will become more crucial as we start talking about 2-level structures that use multiple solution methods.</p> <pre><code class="rs hljs"><span class=hljs-meta >#[derive(Debug, Eq, PartialEq, Hash)]</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">SparseTableIdx</span> {
    <span class=hljs-comment >/// The index where the range in question begins</span>
    start_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The length of the range. This has to always be a power of</span>
    <span class=hljs-comment >/// two</span>
    len: <span class=hljs-type >usize</span>,
}

<span class=hljs-keyword >type</span> <span class="hljs-title class_">DenseTable</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; = HashMap&lt;RMQRange&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;, RMQResult&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt;;
<span class=hljs-keyword >type</span> <span class="hljs-title class_">SparseTable</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; = HashMap&lt;SparseTableIdx, RMQResult&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt;;

<span class=hljs-meta >#[derive(Debug)]</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">RMQResult</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    min_idx: <span class=hljs-type >usize</span>,
    min_value: &amp;<span class=hljs-symbol >&#x27;a</span> T,
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; <span class=hljs-built_in >From</span>&lt;(<span class=hljs-type >usize</span>, &amp;<span class=hljs-symbol >&#x27;a</span> T)&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">RMQResult</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">from</span>((min_idx, min_value): (<span class=hljs-type >usize</span>, &amp;<span class=hljs-symbol >&#x27;a</span> T)) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        RMQResult { min_idx, min_value }
    }
}

<span class=hljs-comment >/// All structures capable of answering range min queries should</span>
<span class=hljs-comment >/// expose the solve method.</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >trait</span> <span class="hljs-title class_">RMQSolver</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">solve</span>(&amp;<span class=hljs-keyword >self</span>, range: &amp;RMQRange&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;) <span class=hljs-punctuation >-&gt;</span> RMQResult&lt;T&gt;;
}</code></pre> <p>We introduce a trait that encodes the necessary and sufficient API that any <code>rmq</code> solver should expose. We need to be able to build the solver and to invoke the solve method with a given range. Below, we introduce the various solvers, all of which we have already seen before – we simply present them here in a unified manner.</p> <pre><code class="rs hljs"><span class=hljs-comment >/// A solver that answers range min queries by </span>
<span class=hljs-comment >/// doing no preprocessing. At query time, it</span>
<span class=hljs-comment >/// simply does a linear scan of the range in question</span>
<span class=hljs-comment >/// to get the answer. This is an &lt;O(1), O(n)&gt; solver</span>
<span class=hljs-meta >#[derive(Debug)]</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">ScanningSolver</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T],
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; ScanningSolver&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >pub</span> <span class=hljs-keyword >fn</span> <span class="hljs-title function_">new</span>(underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T]) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        ScanningSolver { underlying }
    }
}

<span class=hljs-comment >/// A solver that answers `rmq` queries by first pre-computing</span>
<span class=hljs-comment >/// the answers to all possible ranges. At query time, it simply</span>
<span class=hljs-comment >/// makes a table lookup. This is the &lt;O(n*n), O(1)&gt; solver</span>
<span class=hljs-meta >#[derive(Debug)]</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">DenseTableSolver</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T],
    lookup_table: DenseTable&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;,
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span> + Hash&gt; DenseTableSolver&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >pub</span> <span class=hljs-keyword >fn</span> <span class="hljs-title function_">new</span>(underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T]) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >lookup_table</span> = <span class="hljs-title function_ invoke__">compute_rmq_all_ranges</span>(underlying);
        DenseTableSolver {
            underlying,
            lookup_table,
        }
    }
}

<span class=hljs-comment >/// A solver that answers rmq queries by first precomputing</span>
<span class=hljs-comment >/// the answers to ranges whose length is a power of 2</span>
<span class=hljs-comment >/// At query time, it uses a lookup table of `msb(n)` values to</span>
<span class=hljs-comment >/// factor the length of the requested query into powers of</span>
<span class=hljs-comment >/// 2 and then looks up the answers in the sparse table.</span>
<span class=hljs-comment >/// This is the &lt;O(n lg n), O(1)&gt; solver</span>
<span class=hljs-meta >#[derive(Debug)]</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">SparseTableSolver</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T],
    sparse_table: SparseTable&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;,

    <span class=hljs-comment >/// The precomputed and cached array of msb(n)</span>
    <span class=hljs-comment >/// answers for all n between 1 and 1 &lt;&lt; 16</span>
    msb_sixteen_lookup: [<span class=hljs-type >u8</span>; <span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >16</span>],
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span> + Hash&gt; SparseTableSolver&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >pub</span> <span class=hljs-keyword >fn</span> <span class="hljs-title function_">new</span>(underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T]) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >sparse_table</span> = <span class="hljs-title function_ invoke__">compute_rmq_sparse</span>(underlying);
        <span class=hljs-keyword >let</span> <span class=hljs-variable >msb_sixteen_lookup</span> = MSBLookupTable::<span class="hljs-title function_ invoke__">build</span>();
        SparseTableSolver {
            underlying,
            sparse_table,
            msb_sixteen_lookup,
        }
    }
}</code></pre> <p>Below, we implement the <code>RMQSolver</code> trait for each of our solvers. We leverage functions that we already implemented in preceding segments.</p> <pre><code class="rs hljs"><span class=hljs-comment >/// Calculates the location and value of the smallest element</span>
<span class=hljs-comment >/// in the given block by iterating over the elements. This takes</span>
<span class=hljs-comment >/// linear time and is extremely fast for small block sizes (or</span>
<span class=hljs-comment >/// more generally, blocks that can fit in a single cache line)</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">get_min_by_scanning</span>&lt;T: <span class=hljs-built_in >Ord</span>&gt;(block: &amp;[T]) <span class=hljs-punctuation >-&gt;</span> RMQResult&lt;T&gt; {
    <span class=hljs-keyword >let</span> (min_idx, min_value) = block.<span class="hljs-title function_ invoke__">iter</span>()
                                    .<span class="hljs-title function_ invoke__">enumerate</span>()
                                    .<span class="hljs-title function_ invoke__">min_by_key</span>(|x| x.<span class=hljs-number >1</span>)
                                    .<span class="hljs-title function_ invoke__">unwrap</span>();
    RMQResult { min_idx, min_value }
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; RMQSolver&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">ScanningSolver</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">solve</span>(&amp;<span class=hljs-keyword >self</span>, range: &amp;RMQRange&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;) <span class=hljs-punctuation >-&gt;</span> RMQResult&lt;T&gt; {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >range_slice</span> = &amp;<span class=hljs-keyword >self</span>.underlying[range.start_idx..=range.end_idx];
        <span class="hljs-title function_ invoke__">get_min_by_scanning</span>(range_slice)
    }
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span> + <span class=hljs-built_in >Eq</span> + Hash&gt; RMQSolver&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">DenseTableSolver</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">solve</span>(&amp;<span class=hljs-keyword >self</span>, range: &amp;RMQRange&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;) <span class=hljs-punctuation >-&gt;</span> RMQResult&lt;T&gt; {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >res</span> = <span class=hljs-keyword >self</span>.lookup_table.<span class="hljs-title function_ invoke__">get</span>(&amp;range).<span class="hljs-title function_ invoke__">unwrap</span>();
        (res.min_idx, res.min_value.<span class="hljs-title function_ invoke__">clone</span>()).<span class="hljs-title function_ invoke__">into</span>()
    }
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span> + <span class=hljs-built_in >Eq</span> + Hash&gt; RMQSolver&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">SparseTableSolver</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">solve</span>(&amp;<span class=hljs-keyword >self</span>, range: &amp;RMQRange&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;) <span class=hljs-punctuation >-&gt;</span> RMQResult&lt;T&gt; {
        <span class=hljs-keyword >let</span> (i, j) = (range.start_idx, range.end_idx);
        <span class=hljs-keyword >let</span> <span class=hljs-variable >range_len</span> = (j - i) + <span class=hljs-number >1</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-variable >k</span> = <span class=hljs-keyword >self</span>.msb_sixteen_lookup.<span class="hljs-title function_ invoke__">get_msb_idx_of</span>(range_len);
        <span class=hljs-keyword >let</span> <span class=hljs-variable >right_start</span> = j - (<span class=hljs-number >1</span> &lt;&lt; k) + <span class=hljs-number >1</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-variable >left</span>: SparseTableIdx = (i, <span class=hljs-number >1</span> &lt;&lt; k).<span class="hljs-title function_ invoke__">into</span>();
        <span class=hljs-keyword >let</span> <span class=hljs-variable >right</span>: SparseTableIdx = (right_start, <span class=hljs-number >1</span> &lt;&lt; k).<span class="hljs-title function_ invoke__">into</span>();
        <span class=hljs-keyword >let</span> <span class=hljs-variable >left_res</span> = <span class=hljs-keyword >self</span>.sparse_table.<span class="hljs-title function_ invoke__">get</span>(&amp;left).<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class=hljs-keyword >let</span> <span class=hljs-variable >right_res</span> = <span class=hljs-keyword >self</span>.sparse_table.<span class="hljs-title function_ invoke__">get</span>(&amp;right).<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-title function_ invoke__">get_prev_min</span>(<span class=hljs-keyword >self</span>.underlying, left_res, right_res)
    }
}</code></pre> <hr /> <h3 id=two-level_structures ><a href="#two-level_structures" class=header-anchor >Two-Level Structures</a></h3> <p>To apply the method of four russians to the RMQ problem, we begin by dividing the input array into blocks of length <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> If the length of the array is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> this results in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\frac{n}{b})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.6954em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mclose >)</span></span></span></span> blocks. For each of these blocks, we find the index of the smallest value bu doing a simple scan. This takes <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><mi>b</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(b)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">b</span><span class=mclose >)</span></span></span></span> in each block and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy=false >)</mo><mo>∗</mo><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><mi>b</mi><mo stretchy=false >)</mo><mo>=</mo><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\frac{n}{b}) * \mathcal{O}(b) = \mathcal{O}(n)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.6954em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∗</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">b</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mclose >)</span></span></span></span> for all the blocks. We aggregate these min values in a new macro array. Given a query range <code>&#91;i, j&#93;</code> how can we use the blocks and the macro array to satisfy the query? Also, what value of <code>b</code> should we use? To query, we start by figuring out which block the ends of the query fall into. We do that by dividing each end with the block size, i.e <code>start_block &#61; i/b, end_block &#61; j/b</code>. We then scan the items in <code>start_block</code> that appear after <code>i</code> and the items in <code>end_block</code> that appear before <code>j</code> and take the minimal value over them. Let&#39;s call this value, the smallest value at the ends of the range, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span> Then we scan the macro array to find the minimal value among all blocks between <code>start_block</code> and <code>end_block</code>. let&#39;s call this value <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>. The answer to our query is the <code>min</code> &#40;or <code>argmin</code>&#41; between these two values: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><msub><mi>Q</mi><mi>A</mi></msub><mo stretchy=false >(</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo stretchy=false >)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>λ</mi><mo separator=true >,</mo><mi>α</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">RMQ_A(i, j) = \min(\lambda, \alpha)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">RM</span><span class=mord ><span class="mord mathnormal">Q</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop >min</span><span class=mopen >(</span><span class="mord mathnormal">λ</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class=mclose >)</span></span></span></span> How long does this take? Well, finding the <code>min</code> in the end blocks take <code>O&#40;b&#41;</code> and scanning the intermediate blocks takes <code>O&#40;n/b&#41;</code>. This gives us <code>O&#40;b &#43; n/b&#41;</code>. Therefore, to properly characterize the runtime, we need to find the value of <code>b</code> that minimized the expression <code>b &#43; n/b</code>. We do so below</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mtable rowspacing=0.25em  columnalign="right left" columnspacing=0em ><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>b</mi><mo stretchy=false >)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mi>b</mi><mo>+</mo><mfrac><mi>n</mi><mi>b</mi></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><msup><mi>f</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo stretchy=false >(</mo><mi>b</mi><mo stretchy=false >)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mi>n</mi><msup><mi>b</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mi>n</mi><msup><mi>b</mi><mn>2</mn></msup></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><msup><mi>b</mi><mn>2</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mi>b</mi></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><msqrt><mi>n</mi></msqrt></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align*} f(b) &amp;= b + \dfrac{n}{b} \\ f&#x27;(b) &amp;= 1 - \dfrac{n}{b^2}\\ 0 &amp;= 1 - \dfrac{n}{b^2}\\ b^2 &amp;= n \\ b &amp;= \sqrt{n} \end{align*} </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:9.3139em;vertical-align:-4.407em;"></span><span class=mord ><span class=mtable ><span class=col-align-r ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:4.907em;"><span style="top:-6.907em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">b</span><span class=mclose >)</span></span></span><span style="top:-4.8134em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">b</span><span class=mclose >)</span></span></span><span style="top:-2.7199em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord >0</span></span></span><span style="top:-0.8697em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal">b</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:0.6394em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class="mord mathnormal">b</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:4.407em;"><span></span></span></span></span></span><span class=col-align-l ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:4.907em;"><span style="top:-6.907em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.1076em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">n</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-4.8134em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mord >1</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.1076em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal">b</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">n</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.7199em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mord >1</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.1076em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal">b</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">n</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-0.8697em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span><span class="mord mathnormal">n</span></span></span><span style="top:0.6394em;"><span class=pstrut  style="height:3.1076em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8492em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.8092em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.1908em;"><span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:4.407em;"><span></span></span></span></span></span></span></span></span></span></span></span> <p>So, we set <code>b</code> to the square root of <code>n</code>. This gives us a query time of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><msqrt><mi>n</mi></msqrt><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\sqrt{n})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0503em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8003em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2397em;"><span></span></span></span></span></span><span class=mclose >)</span></span></span></span> and an overall time of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>O</mi><mo stretchy=false >(</mo><msup><mi>n</mi><mn>0.5</mn></msup><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle O(n), O(n^{0.5})\rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.0641em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.5</span></span></span></span></span></span></span></span></span><span class=mclose >)⟩</span></span></span></span>.</p> <p>Since our two level structure solutions will eventually mix and match the solvers that they use at each level, we begin by introducing an abstraction to facilitate that. Below, we implement an object that can answer any range min query using parameters that can be set by the client.</p> <pre><code class="rs hljs"><span class=hljs-comment >/// The abstraction for a single block.</span>
<span class=hljs-meta >#[derive(Debug)]</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">RMQBlock</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-comment >/// The starting index. This is 0-indexed and should be</span>
    <span class=hljs-comment >/// less than or equal to the end_idx</span>
    start_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The ending index. This should be strictly less than the</span>
    <span class=hljs-comment >/// length of the underlying array. Further, end_idx - start_idx should</span>
    <span class=hljs-comment >/// be 5 for all except possibly the last block</span>
    end_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The index of the median value in the given range. To move from this</span>
    <span class=hljs-comment >/// index to an idx in the underlying, we simply calculate</span>
    <span class=hljs-comment >/// `start_idx + median_idx`</span>
    min_idx: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// The median of this block</span>
    min: &amp;<span class=hljs-symbol >&#x27;a</span> T,
}

<span class=hljs-comment >//... Implementation of the `From` trait elided</span>

<span class=hljs-comment >/// The primary solvers available.</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >enum</span> <span class="hljs-title class_">RMQSolverKind</span> {
    ScanningSolver,
    DenseTableSolver,
    SparseTableSolver,
}

<span class=hljs-comment >///... Type alias `BlockLevelSolvers` elided</span>

<span class=hljs-comment >/// Since we unified our various solve, we can succinctly represent</span>
<span class=hljs-comment >/// a solver that follows the method of four russians scheme.</span>
<span class=hljs-comment >/// Notice how we allow one to set the block_size, and solvers</span>
<span class=hljs-keyword >pub</span> <span class=hljs-keyword >struct</span> <span class="hljs-title class_">FourRussiansRMQ</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; {
    <span class=hljs-comment >/// This is the entire array. The solvers only operate on slices of</span>
    <span class=hljs-comment >/// this array</span>
    static_array: &amp;<span class=hljs-symbol >&#x27;a</span> [T],

    <span class=hljs-comment >/// As discussed already, block decomposition is at the</span>
    <span class=hljs-comment >/// heart of the method of four russians. We thus</span>
    <span class=hljs-comment >/// allow the client to set how large a single block should be</span>
    block_size: <span class=hljs-type >usize</span>,

    <span class=hljs-comment >/// We call the solve method of this object when we want to</span>
    <span class=hljs-comment >/// answer an `rmq` query over the macro array</span>
    macro_level_solver: <span class=hljs-type >Box</span>&lt;<span class=hljs-keyword >dyn</span> RMQSolver&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt;,

    <span class=hljs-comment >/// We call the solve method of this object when we want to</span>
    <span class=hljs-comment >/// answer an `rmq` query over a single block (ie a micro array)</span>
    block_level_solvers: BlockLevelSolvers&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;,
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; FourRussiansRMQ&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-comment >/// Create a new RMQ solver for `static_array`</span>
    <span class=hljs-comment >/// that uses block decomposition with a block size of `b`.</span>
    <span class=hljs-comment >/// The solver will use the `macro_solver` to solve the </span>
    <span class=hljs-comment >/// instance of the problem on the array of aggregate solutions</span>
    <span class=hljs-comment >/// from the blocks and `micro_solver` to solve the solution in</span>
    <span class=hljs-comment >/// each individual block</span>
    <span class=hljs-keyword >pub</span> <span class=hljs-keyword >fn</span> <span class="hljs-title function_">new</span>(
        static_array: &amp;<span class=hljs-symbol >&#x27;a</span> [T],
        block_size: <span class=hljs-type >usize</span>,
        macro_solver: RMQSolverKind,
        micro_solver: RMQSolverKind,
    ) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >blocks</span> = <span class="hljs-title function_ invoke__">create_blocks</span>(static_array, block_size);
        <span class=hljs-keyword >let</span> <span class=hljs-variable >macro_level_solver</span> = <span class="hljs-title function_ invoke__">create_macro_solver</span>(blocks, macro_solver);
        <span class=hljs-keyword >let</span> <span class=hljs-variable >block_level_solvers</span> = <span class="hljs-title function_ invoke__">gddcreate_micro_solvers</span>(
            static_array, block_size, micro_solver
        );
        FourRussiansRMQ {
            static_array,
            block_size,
            macro_level_solver,
            block_level_solvers,
        }
    }

    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">create_blocks</span>(array: &amp;[T], b: <span class=hljs-type >usize</span>) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >Vec</span>&lt;RMQBlock&lt;<span class=hljs-symbol >&#x27;_</span>, T&gt;&gt; {
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >blocks</span> = <span class=hljs-type >Vec</span>::&lt;RMQBlock&lt;T&gt;&gt;::<span class="hljs-title function_ invoke__">with_capacity</span>(array.<span class="hljs-title function_ invoke__">len</span>() / b);
        <span class=hljs-keyword >for</span> <span class=hljs-variable >start_idx</span> <span class=hljs-keyword >in</span> (<span class=hljs-number >0</span>..array.<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">step_by</span>(b) {
            <span class=hljs-keyword >let</span> <span class=hljs-variable >end_idx</span> = (start_idx + b) - <span class=hljs-number >1</span>;
            <span class=hljs-keyword >let</span> <span class=hljs-variable >block</span> = array[start_idx..=end_idx].<span class="hljs-title function_ invoke__">as_ref</span>();
            <span class=hljs-keyword >let</span> <span class=hljs-variable >rmq_res</span> = <span class="hljs-title function_ invoke__">get_min_by_scanning</span>(block);
            blocks.<span class="hljs-title function_ invoke__">push</span>((start_idx, end_idx, rmq_res).<span class="hljs-title function_ invoke__">into</span>())
        }
        blocks
    }

    <span class=hljs-comment >/// Find the smallest element in the range</span>
    <span class=hljs-comment >/// provided (i, j). This works by finding the</span>
    <span class=hljs-comment >/// minimum among three answers:</span>
    <span class=hljs-comment >///     (a) The smallest value in the valid portion of i&#x27;s block</span>
    <span class=hljs-comment >///     (b) The smallest value in the valid portion of j&#x27;s block</span>
    <span class=hljs-comment >///     (c) The smallest value in the intermediate blocks</span>
    <span class=hljs-keyword >pub</span> <span class=hljs-keyword >fn</span> <span class="hljs-title function_">rmq</span>(range: RMQRange&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;) <span class=hljs-punctuation >-&gt;</span> RMQResult&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
        todo!()
    }
}</code></pre> <p>With the above abstraction in place, we can implement the two-level solution discussed in the preceding section as an instance of the <code>FourRussiansRMQ</code> with both <code>macro_solver</code> and <code>micro_solver</code> set to <code>ScanningSolver</code> and <code>b</code> set to <code>sqrt&#40;n&#41;</code>. We do so below.</p> <pre><code class="rs hljs"><span class=hljs-comment >/// WIP: The FourRussiansRMQ that uses the ScanningSolver </span>
<span class=hljs-comment >/// for both the micro and macro arrays along with a block</span>
<span class=hljs-comment >/// size of sqrt(n)</span></code></pre> <p>So, Block decomposition allowed us to have linear pre-processing time. However, in the process, we lost our constant query time? Can we do better than <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8003em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2397em;"><span></span></span></span></span></span></span></span></span> while still maintaining a linear pre-processing time? Yes. We can use a mix of block decomposition and sparse tables to achieve this. Let&#39;s see how. </p> <h3 id=hybrid_structures ><a href="#hybrid_structures" class=header-anchor >Hybrid Structures</a></h3> <p>When discussing block decomposition, after decomposing the input into micro arrays, we went ahead and solved the original problem on each block, treating each as a reduced instance of the original. We also did the same for the macro array. In the preceding section, we solved the problem by doing a linear scan. We can, however, use methods from previous sections – sparse and dense lookup tables to solve the problem on the micro and macro arrays. When we do that, we end up with hybrid solutions that have faster query times. In this section, we shall explore a few hybrid structures and characterize their runtime.</p> <p>To create a hybrid structure, we need to decide which method we want to use to solve the problem on the macro array and on each micro array. By mixing and matching methods, we get different hybrids with different runtimes as shown in the table below.</p> <table><tr><th align=right >Block Size<th align=right >Macro Array Method<th align=right >Micro Array Method<th align=right >Runtime<tr><td align=right ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lg</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\lg n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span><td align=right >Sparse Table<td align=right >Linear Scan<td align=right ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>O</mi><mo stretchy=false >(</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle O(n), O(\lg n)\rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)⟩</span></span></span></span><tr><td align=right ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lg</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\lg n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span><td align=right >Sparse Table<td align=right >Sparse Table<td align=right ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mi>lg</mi><mo>⁡</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>O</mi><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle O(n \lg \lg n), O(1)\rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mord >1</span><span class=mclose >)⟩</span></span></span></span><tr><td align=right ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lg</mi><mo>⁡</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\lg n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span><td align=right >The first hybrid in this table<td align=right >Sparse Table<td align=right ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >⟨</mo><mi>O</mi><mo stretchy=false >(</mo><mi>n</mi><mo stretchy=false >)</mo><mo separator=true >,</mo><mi>O</mi><mo stretchy=false >(</mo><mi>lg</mi><mo>⁡</mo><mi>lg</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false >)</mo><mo stretchy=false >⟩</mo></mrow><annotation encoding="application/x-tex">\langle O(n), O(\lg \lg n) \rangle</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >⟨</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mclose >)</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mclose >)⟩</span></span></span></span></table> <p>Below, we implement the first hybrid method</p> <pre><code class="rs hljs"><span class=hljs-comment >/// WIP: The FourRussiansRMQ that uses the ScanningSolver </span>
<span class=hljs-comment >/// for both the micro and a SparseTableSolver for the macro </span>
<span class=hljs-comment >/// array along with a block size of lg (n)</span></code></pre> <p>By this point we have a cool and quite efficient algorithm for the offline range min query problem. However, the title of the note did promise an <code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code> solution. We discuss that in the next section with the caveat that the added constant factors that give us asymptotic constant query time may slow down the algorithm in practice. As noted <a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1196/lectures/01/Small01.pdf">here</a>, the preceding <code>&lt;O&#40;n&#41;, O&#40;lg&#41;&gt;</code> hybrid solution outperforms the <code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code> solution in practice.</p> <h2 id=cartesian_trees_the_lca-rmq_equivalence ><a href="#cartesian_trees_the_lca-rmq_equivalence" class=header-anchor >Cartesian Trees &amp; The LCA-RMQ Equivalence</a></h2> <p>To fully understand the upcoming <code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code> solution, we need to to first get an intimate understanding of Cartesian Trees. They are largely responsible for the constant time lookup. In this section, we begin by discussing what cartesian trees are and how to efficiently construct them. We then implement a cartesian tree.</p> <h3 id=cartesian_trees ><a href="#cartesian_trees" class=header-anchor >Cartesian Trees</a></h3> <p>A cartesian tree is a derivative data structure. It is derived from an underlying array. More formally, the cartesian tree <code>T</code> of an array <code>A</code> is a min binary heap of the elements of <code>A</code> organized such that an in order traversal of the tree yields the original array. How can we construct such a tree given some input array? The main observations that will guide our construction will be the requirement that an in-order traversal must yield the array elements in their positional order, and the requirement that the tree be a min heap. During an in-order traversal, the right child is retrieved after both the parent and the left child – consequently, the right-most node will be the last node retrieved. We can thus build the tree <a href="https://www.notion.so/A-note-on-algorithmic-design-patterns-20e50d39c99945e3ad8dfb804177ab3f">incrementally</a>, adding each new element as the rightmost node of the tree.</p> <p>More specifically, we&#39;ll build the cartesian tree incrementally – adding in elements in the order that they appear in the array. To add an element <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span></span></span></span>, we inspect the right spine of the tree starting with the right most node. We follow parent pointers until we find an element, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span></span></span>, in the tree that is smaller than <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span></span></span></span>. We modify the tree, making <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span></span></span></span> a right child of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span></span></span>. We also make the rest of the right subtree that is below <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span></span></span></span> a left subtree of the new node. Traversing the right spine of tree from the right-most node can be done efficiently by keeping nodes on the right spine in a stack. That way, the rightmost node is always at the top of the stack. Below, we use this observation to implement a procedure for creating a cartesian tree from some array.</p> <pre><code class="rs hljs"><span class=hljs-comment >/// As always, we use the `wrapped index pattern`</span>
<span class=hljs-comment >///</span>
<span class=hljs-comment >/// An index into a collection of cartesian tree nodes</span>
<span class=hljs-meta >#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Clone)]</span>
<span class=hljs-keyword >struct</span> <span class="hljs-title class_">CartesianNodeIdx</span>(<span class=hljs-type >usize</span>);

<span class=hljs-meta >#[derive(Debug)]</span>
<span class=hljs-keyword >struct</span> <span class="hljs-title class_">CartesianTreeNode</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; {
    <span class=hljs-comment >/// A reference to the array value that this node represents</span>
    value: &amp;<span class=hljs-symbol >&#x27;a</span> T,

    <span class=hljs-comment >/// The locations of the children and parent of this node.</span>
    left_child_idx: <span class=hljs-type >Option</span>&lt;CartesianNodeIdx&gt;,
    right_child_idx: <span class=hljs-type >Option</span>&lt;CartesianNodeIdx&gt;,
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; std::ops::Index&lt;CartesianNodeIdx&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">Vec</span>&lt;CartesianTreeNode&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt; {
    <span class=hljs-keyword >type</span> <span class="hljs-title class_">Output</span> = CartesianTreeNode&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;;
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">index</span>(&amp;<span class=hljs-keyword >self</span>, index: CartesianNodeIdx) <span class=hljs-punctuation >-&gt;</span> &amp;<span class=hljs-keyword >Self</span>::Output {
        &amp;<span class=hljs-keyword >self</span>[index.<span class=hljs-number >0</span>]
    }
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; std::ops::IndexMut&lt;CartesianNodeIdx&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">Vec</span>&lt;CartesianTreeNode&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">index_mut</span>(&amp;<span class=hljs-keyword >mut</span> <span class=hljs-keyword >self</span>, index: CartesianNodeIdx) <span class=hljs-punctuation >-&gt;</span> &amp;<span class=hljs-keyword >mut</span> <span class=hljs-keyword >Self</span>::Output {
        &amp;<span class=hljs-keyword >mut</span> <span class=hljs-keyword >self</span>[index.<span class=hljs-number >0</span>]
    }
}
<span class=hljs-comment >/// A cartesian tree is a heap ordered binary tree</span>
<span class=hljs-comment >/// derived from some underlying array. An in-order</span>
<span class=hljs-comment >/// traversal of the tree yields the underlying tree.</span>
<span class=hljs-meta >#[derive(Debug)]</span>
<span class=hljs-keyword >struct</span> <span class="hljs-title class_">CartesianTree</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; {
    nodes: <span class=hljs-type >Vec</span>&lt;CartesianTreeNode&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt;,
    root_idx: <span class=hljs-type >Option</span>&lt;CartesianNodeIdx&gt;,
    action_profile: <span class=hljs-type >Vec</span>&lt;CartesianTreeAction&gt;,
}

<span class=hljs-comment >/// When constructing a cartesian tree, we either</span>
<span class=hljs-comment >/// push a node to or pop a node from a stack.</span>
<span class=hljs-comment >/// We keep track of these actions because we can</span>
<span class=hljs-comment >/// use them to generate the cartesian tree number.</span>
<span class=hljs-meta >#[derive(Debug, Eq, PartialEq)]</span>
<span class=hljs-keyword >enum</span> <span class="hljs-title class_">CartesianTreeAction</span> {
    Push,
    Pop,
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; <span class=hljs-built_in >From</span>&lt;&amp;<span class=hljs-symbol >&#x27;a</span> T&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">CartesianTreeNode</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">from</span>(value: &amp;<span class=hljs-symbol >&#x27;a</span> T) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        CartesianTreeNode {
            value,
            left_child_idx: <span class=hljs-literal >None</span>,
            right_child_idx: <span class=hljs-literal >None</span>,
        }
    }
}

<span class=hljs-comment >// To create the cartesian tree, we pop the stack until either</span>
<span class=hljs-comment >// it&#x27;s empty or the element atop the stack has a smaller value</span>
<span class=hljs-comment >// than the element we are currently trying to add to the stack.</span>
<span class=hljs-comment >// Once we break out of the `pop` loop, we make the item we popped</span>
<span class=hljs-comment >// a left child of the new item we are adding. Additionally, we make</span>
<span class=hljs-comment >// this new item a right/left child of the item atop the stack</span>
<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; <span class=hljs-built_in >From</span>&lt;&amp;<span class=hljs-symbol >&#x27;a</span> [T]&gt; <span class=hljs-keyword >for</span> <span class="hljs-title class_">CartesianTree</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">from</span>(underlying: &amp;<span class=hljs-symbol >&#x27;a</span> [T]) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-keyword >Self</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >len</span> = underlying.<span class="hljs-title function_ invoke__">len</span>();
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >nodes</span> = <span class=hljs-type >Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(len);
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >stack</span> = <span class=hljs-type >Vec</span>::&lt;CartesianNodeIdx&gt;::<span class="hljs-title function_ invoke__">with_capacity</span>(len);
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >action_profile</span> = <span class=hljs-type >Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(len * <span class=hljs-number >2</span>);
        <span class="hljs-title function_ invoke__">for</span> (idx, value) <span class=hljs-keyword >in</span> underlying.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() {
            nodes.<span class="hljs-title function_ invoke__">push</span>(value.<span class="hljs-title function_ invoke__">into</span>());
            <span class=hljs-keyword >let</span> <span class=hljs-variable >node_idx</span> = <span class="hljs-title function_ invoke__">CartesianNodeIdx</span>(idx);
            <span class="hljs-title function_ invoke__">add_node_to_cartesian_tree</span>(&amp;<span class=hljs-keyword >mut</span> nodes, &amp;<span class=hljs-keyword >mut</span> stack, &amp;<span class=hljs-keyword >mut</span> action_profile, node_idx);
        }
        <span class=hljs-keyword >let</span> <span class=hljs-variable >root_idx</span> = stack.<span class="hljs-title function_ invoke__">first</span>().<span class="hljs-title function_ invoke__">map</span>(|min| min.<span class="hljs-title function_ invoke__">clone</span>());
        CartesianTree {
            nodes,
            root_idx,
            action_profile,
        }
    }
}

<span class=hljs-keyword >type</span> <span class="hljs-title class_">Nodes</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; = <span class=hljs-type >Vec</span>&lt;CartesianTreeNode&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt;&gt;;
<span class=hljs-keyword >type</span> <span class="hljs-title class_">Stack</span> = <span class=hljs-type >Vec</span>&lt;CartesianNodeIdx&gt;;
<span class=hljs-keyword >type</span> <span class="hljs-title class_">Actions</span> = <span class=hljs-type >Vec</span>&lt;CartesianTreeAction&gt;;
<span class=hljs-comment >/// Adds the node at the given idx into the tree by wiring up the</span>
<span class=hljs-comment >/// child and parent pointers. it is assumed that the</span>
<span class=hljs-comment >/// node has already been added to `nodes` the list of nodes.</span>
<span class=hljs-comment >/// This procedure returns an optional index value</span>
<span class=hljs-comment >/// that is populated if the root changed.</span>
<span class=hljs-keyword >fn</span> <span class="hljs-title function_">add_node_to_cartesian_tree</span>&lt;T: <span class=hljs-built_in >Ord</span>&gt;(
    nodes: &amp;<span class=hljs-keyword >mut</span> Nodes&lt;T&gt;,
    stack: &amp;<span class=hljs-keyword >mut</span> Stack,
    actions: &amp;<span class=hljs-keyword >mut</span> Actions,
    new_idx: CartesianNodeIdx,
) {
    <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >last_popped</span> = <span class=hljs-literal >None</span>;
    <span class=hljs-keyword >loop</span> {
        <span class=hljs-keyword >match</span> stack.<span class="hljs-title function_ invoke__">last</span>() {
            <span class=hljs-literal >None</span> =&gt; <span class=hljs-keyword >break</span>,
            <span class="hljs-title function_ invoke__">Some</span>(top_node_idx) =&gt; {
                <span class=hljs-comment >// If the new node is greater than the value atop the stack,</span>
                <span class=hljs-comment >// we make the new node a right child of that value</span>
                <span class=hljs-keyword >if</span> nodes[top_node_idx.<span class="hljs-title function_ invoke__">clone</span>()].value &lt; nodes[new_idx.<span class="hljs-title function_ invoke__">clone</span>()].value {
                    nodes[top_node_idx.<span class="hljs-title function_ invoke__">clone</span>()].right_child_idx = <span class="hljs-title function_ invoke__">Some</span>(new_idx.<span class="hljs-title function_ invoke__">clone</span>());
                    <span class=hljs-keyword >break</span>;
                }
                last_popped = stack.<span class="hljs-title function_ invoke__">pop</span>();
                actions.<span class="hljs-title function_ invoke__">push</span>(CartesianTreeAction::Pop);
            }
        }
    }
    <span class=hljs-comment >// We make the last item we popped a left child of the</span>
    <span class=hljs-comment >// new node</span>
    <span class=hljs-keyword >if</span> <span class=hljs-keyword >let</span> <span class=hljs-variable >Some</span>(last_popped_idx) = last_popped {
        nodes[new_idx.<span class="hljs-title function_ invoke__">clone</span>()].left_child_idx = <span class="hljs-title function_ invoke__">Some</span>(last_popped_idx);
    }
    stack.<span class="hljs-title function_ invoke__">push</span>(new_idx);
    actions.<span class="hljs-title function_ invoke__">push</span>(CartesianTreeAction::Push);
}

<span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; CartesianTree&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">in_order_traversal</span>(&amp;<span class=hljs-keyword >self</span>) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >Vec</span>&lt;&amp;T&gt; {
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >res</span> = <span class=hljs-type >Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class=hljs-keyword >self</span>.nodes.<span class="hljs-title function_ invoke__">len</span>());
        <span class=hljs-keyword >self</span>.<span class="hljs-title function_ invoke__">traversal_helper</span>(&amp;<span class=hljs-keyword >self</span>.root_idx, &amp;<span class=hljs-keyword >mut</span> res);
        res
    }

    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">traversal_helper</span>(&amp;<span class=hljs-keyword >self</span>, cur_idx: &amp;<span class=hljs-type >Option</span>&lt;CartesianNodeIdx&gt;, res: &amp;<span class=hljs-keyword >mut</span> <span class=hljs-type >Vec</span>&lt;&amp;<span class=hljs-symbol >&#x27;a</span> T&gt;) {
        <span class=hljs-keyword >let</span> <span class=hljs-variable >nodes</span> = &amp;<span class=hljs-keyword >self</span>.nodes;
        <span class=hljs-keyword >match</span> cur_idx {
            <span class=hljs-literal >None</span> =&gt; {}
            <span class="hljs-title function_ invoke__">Some</span>(cur_sub_root) =&gt; {
                <span class=hljs-keyword >self</span>.<span class="hljs-title function_ invoke__">traversal_helper</span>(&amp;nodes[cur_sub_root.<span class="hljs-title function_ invoke__">clone</span>()].left_child_idx, res);
                res.<span class="hljs-title function_ invoke__">push</span>(&amp;nodes[cur_sub_root.<span class="hljs-title function_ invoke__">clone</span>()].value);
                <span class=hljs-keyword >self</span>.<span class="hljs-title function_ invoke__">traversal_helper</span>(&amp;nodes[cur_sub_root.<span class="hljs-title function_ invoke__">clone</span>()].right_child_idx, res);
            }
        }
    }
}</code></pre> <p>You can play around with the code for constructing a cartesian tree in <a href="https://play.rust-lang.org/?version&#61;stable&amp;mode&#61;debug&amp;edition&#61;2018&amp;gist&#61;c51356cba92f48f0434c64abd21d7162">the rust playground</a>.</p> <hr /> <p>Why are cartesian trees important, and how are they related to the <code>RMQ</code> problem? First, notice that once we have a cartesian tree for an array, we can answer any <code>RMQ</code> on that array. In particular, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><msub><mi>Q</mi><mi>A</mi></msub><mo stretchy=false >(</mo><mi>i</mi><mo separator=true >,</mo><mi>j</mi><mo stretchy=false >)</mo><mo>=</mo><mi>L</mi><mi>C</mi><msub><mi>A</mi><mi>T</mi></msub><mo stretchy=false >(</mo><mi>A</mi><mo stretchy=false >[</mo><mi>i</mi><mo stretchy=false >]</mo><mo separator=true >,</mo><mi>A</mi><mo stretchy=false >[</mo><mi>j</mi><mo stretchy=false >]</mo><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">RMQ_A(i, j) = LCA_T(A[i], A[j])</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">RM</span><span class=mord ><span class="mord mathnormal">Q</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">i</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mord ><span class="mord mathnormal">A</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">A</span><span class=mopen >[</span><span class="mord mathnormal">i</span><span class=mclose >]</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class=mopen >[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class=mclose >])</span></span></span></span> That is we can answer <code>RMQ</code> by doing lowest common ancestor searches in the cartesian tree. Although this idea is intrinsically interesting, we do not explore it further. Feel free to check out <a href="http://courses.csail.mit.edu/6.851/fall17/scribe/lec15.pdf">this note for further details</a>.</p> <p>To fully appreciate the importance of cartesian trees and their relation to the data structure design problem at hand, we have to explore when and how two arrays have isomorphic trees. This will lead us to a way of figuring out when two blocks can share the same pre-processed index – a thing that will lead us to an <code>RMQ</code> data structure with constant query time.</p> <h3 id=cartesian_tree_isomorphisms ><a href="#cartesian_tree_isomorphisms" class=header-anchor >Cartesian Tree Isomorphisms</a></h3> <p>When do two cartesian trees for two different arrays, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">B_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">B_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> have the same shape? How can we tell this efficiently? Put simply, if two blocks have the same shape, then their minimal values of any range in both blocks occur at the same index. This means that, the sequence of <code>Push</code> and <code>Pop</code> operations when constructing the cartesian trees for the two blocks are exactly the same. Therefore, to know if two blocks are isomorphic, we could simply compare their action profiles. Note, however, when we are only interested in whether two blocks have isomorphic trees, we don&#39;t even need to construct the tree. We also do not need to allocate space for the action profile vector. The idea is to create a a bitstring from the sequence of <code>Push</code> and <code>Pop</code> operations. The number formed by this bitstring is called the cartesian tree number. Therefore, with this scheme, two blocks have isomorphic trees if they have the same cartesian tree number. Below, we show how to calculate such a number from the action profile. </p> <pre><code class="rs hljs"><span class=hljs-keyword >impl</span>&lt;<span class=hljs-symbol >&#x27;a</span>, T: <span class=hljs-built_in >Ord</span>&gt; CartesianTree&lt;<span class=hljs-symbol >&#x27;a</span>, T&gt; {
    <span class=hljs-comment >/// Calculates the cartesian tree number of this tree</span>
    <span class=hljs-comment >/// using the sequence of `push` and `pop` operations</span>
    <span class=hljs-comment >/// stored in the `action_profile`. Note that calculating this</span>
    <span class=hljs-comment >/// value only makes sense when the underlying array is small.</span>
    <span class=hljs-comment >/// More specifically, this procedure assumes that the underlying</span>
    <span class=hljs-comment >/// array has at most 32 items. This makes sense in our context</span>
    <span class=hljs-comment >/// since we&#x27;re mostly interested in the cartesian tree numbers</span>
    <span class=hljs-comment >/// of RMQ blocks</span>
    <span class=hljs-keyword >fn</span> <span class="hljs-title function_">cartesian_tree_number</span>(&amp;<span class=hljs-keyword >self</span>) <span class=hljs-punctuation >-&gt;</span> <span class=hljs-type >u64</span> {
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >number</span> = <span class=hljs-number >0</span>;
        <span class=hljs-keyword >let</span> <span class=hljs-keyword >mut </span><span class=hljs-variable >offset</span> = <span class=hljs-number >0</span>;
        <span class=hljs-keyword >for</span> <span class=hljs-variable >action</span> <span class=hljs-keyword >in</span> &amp;<span class=hljs-keyword >self</span>.action_profile {
            <span class=hljs-keyword >if</span> action == &amp;CartesianTreeAction::Push {
                number |= <span class=hljs-number >1</span> &lt;&lt; offset;
            }
            offset += <span class=hljs-number >1</span>;
        }
        number
    }
}</code></pre> <p>A nice consequence of the preceding discussion is that we can say something about the number of possible cartesian trees for an array of a given length <code>b</code>. Note that, the maximum length of the action profile is <code>2b</code>. Therefore, the largest cartesian tree number that can be produced is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>2</mn><mi>b</mi></mrow></msup><mo>=</mo><msup><mn>4</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">2^{2b} = 4^b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8491em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8491em;"></span><span class=mord ><span class=mord >4</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>. This number will come in handy when we analyze the runtime of the <code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code> solution.</p> <h3 id=the_fischer-heun_rmq_structure ><a href="#the_fischer-heun_rmq_structure" class=header-anchor >The Fischer-Heun RMQ Structure</a></h3> <p>How does all this talk of cartesian trees and cartesian numbers translate into an <code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code> range min query solution? Let&#39;s discuss that next.</p> <p>As with the other methods, we begin by dividing the underlying array into blocks of <code>b</code> items. For each of our <code>ceil&#40;n/b&#41;</code> blocks, we find the location of the smallest element by scanning. We then aggregate the min locations for all blocks in what we call the macro array. To answer an <code>rmq</code> query, we simply return the smallest value from three smaller <code>rmqs</code>: &#40;a&#41; The block of the starting index, &#40;b&#41; The block of the ending index, and &#40;c&#41; The macro array. So far, this is just a recap from the previous discussion.</p> <p>We are yet to answer two key questions though: &#40;a&#41; What should our block size <code>b</code> be? and &#40;b&#41; What methods &#40;<code>SolverKinds</code>&#41; should we use to answer queries on the macro and micro arrays? The judiciously picking the block size and cleverly applying our solvers, we shall arrive at an <code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code> method.</p> <p>We shall use the <code>SparseTableSolver</code> to solve queries on the macro array. For each block, we shall use the <code>DenseTableSolver</code>. However, if two blocks have the same cartesian tree number, we shall have them share solvers. We can do this because, as mentioned earlier, two blocks have the same cartesian numbers iff they have isomorphic cartesian trees which further implies that min values for both blocks occur at the exact same indexes. Since we use precomputed lookup tables, the query time is obviously <code>O&#40;1&#41;</code>. How about the preprocessing time?</p> <p>The preprocessing time is an amalgamation of three terms:</p> <ol> <li><p>The time used to divide the input into blocks and create the blocks. This, as we saw earlier, is <code>O&#40;n&#41;</code></p> <li><p>The time used to create the solver for the macro array. Since we are using the <code>SparseTableSolver</code> we know that this will be <code>O&#40;n/b lg n&#41;</code>. Note that in past sections, we picked <code>b &#61; lg n</code>. We have yet to choose the value of <code>b</code>.</p> <li><p>And finally, the time used to create solvers for each block. Since we are using the <code>DenseTableSolver</code>, we know that this time will be quadratic. That is, the time to create a solver for a single block will be <code>b^2</code>. Since we are sharing solvers between blocks, we need to multiply the time we spend on each block by the number of distinct blocks of size <code>b</code>. As we saw earlier, this value is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>2</mn><mi>b</mi></mrow></msup><mo>=</mo><msup><mn>4</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">2^{2b} = 4^b</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8491em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.8491em;"></span><span class=mord ><span class=mord >4</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span>. </p> </ol> <p>Therefore, our expression for the preprocessing time is <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=script >O</mi><mo stretchy=false >(</mo><mi>n</mi><mo>+</mo><mo stretchy=false >⌈</mo><mfrac><mi>n</mi><mi>b</mi></mfrac><mo stretchy=false >⌉</mo><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><msup><mn>4</mn><mi>b</mi></msup><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n + \lceil\frac{n}{b}\rceil + b^24^b)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class=mopen >(</span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1.095em;vertical-align:-0.345em;"></span><span class=mopen >⌈</span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.6954em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mclose >⌉</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1.0991em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">b</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mord ><span class=mord >4</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>. Our final task is thus to pick a value of <code>b</code> that will make this expression evaluate to <code>O&#40;n&#41;</code>. Long story short, we pick <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>0.5</mn><msub><mrow><mi>lg</mi><mo>⁡</mo></mrow><mn>4</mn></msub><mi>n</mi><mo>=</mo><mi>O</mi><mi mathvariant=normal >.</mi><mn>25</mn><msub><mrow><mi>lg</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">b = 0.5 \lg_4 n = O.25 \lg_2 n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.9386em;vertical-align:-0.2441em;"></span><span class=mord >0.5</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop ><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2441em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class=mord >.25</span><span class=mspace  style="margin-right:0.1667em;"></span><span class=mop ><span class=mop >l<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.2441em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p> <p>To summarize, by choosing a block size of <code>0.25 lg n</code> and using shared dense table solvers to solve the micro level <code>rmqs</code> &#40;where we use cartesian tree numbers to figure out when to share solvers&#41;, and a sparse table solver for the macro array, we&#39;re able to solve the <code>RMQ</code> problem in <code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code>. However, the <code>O&#40;n&#41;</code> preprocessing time does hide a large constant factor. Think of the trouble we went through to compute the to calculate cartesian trees.</p> <p>Thus, our final data structure has the following features:</p> <table><tr><th align=right >Block Size<th align=right >Macro Array Method<th align=right >Micro Array Method<th align=right >Runtime<tr><td align=right ><code>0.25 lg n</code><td align=right >Sparse Table<td align=right >Sparse Table with Cartesian Tree based caching<td align=right ><code>&lt;O&#40;n&#41;, O&#40;1&#41;&gt;</code></table> <p>As discussed earlier, although this method has impressive asymptotic numbers, it is often outperformed in practice by the hybrid with logarithmic query time. Furthermore, this method is a lot more complex. That is another reason, from an engineering standpoint, to prefer the <code>&lt;O&#40;n&#41;, O&#40;lg&#41;&gt;</code> – much less code, and just as fast.</p> <p>We leave the implementation of this scheme as an exercise. Using the abstractions from above, the implementation should be a simple extension. We simply have to keep track of a mapping from blocks to cartesian tree numbers and modify <code>BlockLevelSolvers</code> to map from cartesian tree numbers instead of blocks.</p> <h2 id=references ><a href="#references" class=header-anchor >References</a></h2> <ol> <li><p><a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1196/lectures/00/Small00.pdf">CS 166 Lecture 1</a></p> <li><p><a href="http://web.stanford.edu/class/archive/cs/cs166/cs166.1196/lectures/01/Small01.pdf">CS 166 Lecture 2</a></p> <li><p><a href="http://courses.csail.mit.edu/6.851/fall17/lectures/L15.pdf">6.851</a></p> </ol> <pre><code class="latex hljs">@article{jlikhuva2021rmq,
  title   = &quot;Rusty Solutions to the Range-Min Query Problem.&quot;,
  author  = &quot;Okonda, Joseph&quot;,
  journal = &quot;https://github.com/jlikhuva/blog&quot;,
  year    = &quot;2021&quot;,
  url     = &quot;https://github.com/jlikhuva/blog/blob/main/posts/rmq.md&quot;
}</code></pre> <div class=page-foot > Okonda, Joseph L. Version as of February 07, 2023. Crafted using <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">Julia</a>. </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script> </div> </main>